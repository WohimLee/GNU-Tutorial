
## 编译原理
### 1 hello, world 在计算机的表示
一个 `hello` 程序的生命周期始于源程序（源文件），例如程序员通过编辑器创建并保存的文本文件 `hello.c`。源程序本质上是由一系列字符组成的文本。在存储到磁盘时，这些字符会按照某种编码方式（通常是 `ASCII`）转换为二进制的 `0` 和 `1 `序列。

在 `ASCII` 编码中，每个字符都对应一个唯一的整数值，并以 单字节形式存储。于是，`hello.c` 文件最终就是一串按字节组织的比特序列。

这种表示方式揭示了计算机系统中的一个核心思想：无论是磁盘文件、内存中的程序，还是用户数据与网络传输的数据，系统中的所有信息最终都是由比特序列表示的。
<div align='center'>
    <image src='imgs/ASCII.png' width=600>
</div>



### 2 编译过程
hello 程序的生命周期始于一个由程序员编写的 C 源代码文件（如 `hello.c`）。为了让计算机能够运行该程序，源代码必须经过一系列的翻译步骤，被转换成 **机器能够直接执行的指令**

具体来说，每条 `C` 语句会逐步转化为机器语言指令。这些指令及相关信息会按照一种标准的 **可执行目标文件格式**（如 `ELF` 在 Linux 上、`PE` 在 Windows 上）打包，并最终以二进制文件的形式存放在磁盘中

在 Linux 系统中，常用的 **GCC 编译器** 会完成这个翻译过程，它将 hello.c 转换为一个可执行文件 hello。这个过程分为四个阶段：

- **预处理（Preprocessing）**: 处理 #include、#define 等指令，生成纯粹的 C 源代码
- **编译（Compilation）**: 将 C 源代码翻译成汇编代码
- **汇编（Assembly）**: 把汇编代码转换为机器指令，形成目标文件（object file）
- **链接（Linking）**: 将目标文件与所需的库文件（如标准库函数）整合，生成最终的可执行目标文件

执行这四个阶段的工具程序（预处理器、编译器、汇编器和链接器）共同组成了 **编译系统（compilation system）**

</div align=center>
    <image src="imgs/compilesystem.png" width=800>
<div>



#### 2.1 预处理阶段

**预处理器（cpp）** 会根据以 # 开头的指令修改原始 C 源程序。例如，在 hello.c 的第 1 行：
```cpp
#include <stdio.h>
```

这条命令告诉预处理器将系统头文件 stdio.h 的内容插入到程序文本中。处理完成后，得到的结果仍然是一个 C 程序，通常扩展名为 .i。

#### 2.2 编译阶段

**编译器（cc1）** 将 `hello.i` 翻译成汇编代码文件 hello.s。该文件以文本形式描述了低级的汇编语言指令，例如：
```asm
main:
    subq    $8, %rsp
    movl    $.LC0, %edi
    call    puts
    movl    $0, %eax
    addq    $8, %rsp
    ret
```

这里的每条汇编语句都对应一条或几条机器指令。汇编语言提供了一种对机器指令的可读表示，方便不同高级语言的编译器输出统一的目标。

#### 2.3 汇编阶段

**汇编器（as）** 将 `hello.s` 翻译成机器语言指令，并将这些指令及相关符号表打包成一种称为 可重定位目标文件（relocatable object file） 的格式，保存为二进制文件 `hello.o`

- `hello.o` 文件包含 `main` 函数的机器指令编码，以及额外的元信息（如 ELF 文件头、符号表等）
- 如果用文本编辑器打开 `hello.o`，会看到大量“乱码”，因为它是二进制格式而非文本

#### 2.4 链接阶段

我们的 hello 程序调用了标准库函数 printf。这个函数并不在 hello.o 文件里，而是在 C 标准库（libc）中，通常以预编译好的目标文件集合存在（`静态库 .a` 或 `共享库 .so`）

**链接器（ld）** 负责将 hello.o 与所需的库文件（如包含 printf 的 libc）进行合并，解析外部符号引用，最终生成 可执行目标文件 hello。

这个 hello 文件就是可以被操作系统加载到内存并运行的 可执行文件。
